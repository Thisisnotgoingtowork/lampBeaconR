#' read NCBI names file
#'
#' yhid function reads from excel files generated by the ABI StepOnePlus. read from the (8) line and initial the cycles, return a list of lamp and melt amplitude
#'
#' @param rawFile a string giving the path to an NCBI name file to read from (both gzipped or uncompressed files are ok)
#' @param meltFile a string giving the path to a NCBI name file, work the same as rawFile, this is a backup if there are second file reading
#' @param meltStart a number indicate the staring cycle of the melt curve.
#' @param timePerCyle a number indicate the seconds per cycle
#' @param skipCycles a number indicate where to read the cycles
#' @param skip description
#' @param sep a string indicate how to separate the data from
#' @param correctCycles a bool value, that set to tell if the file is in right version
#' @param rawDataTab the name of the tab Excel sheet
#' @param meltRawTab the name of the tab Excel sheet of melt curve
#' @return a list of lamp and melt amplitude table
#' @export




readLamp<-function(rawFile,meltFile=rawFile,meltStart=121,timePerCyle=30,skipCycles=0,skip=21,sep=',',correctCycles=FALSE,rawDataTab='Raw Data',meltRawTab='Melt Curve Raw Data'){
  if(grepl('.xlsx?$',rawFile)){
    melt<-as.data.frame(readxl::read_excel(rawFile,rawDataTab,skip=skip))
    colnames(melt)<-sub('[- ]','.',colnames(melt))
  }else{
    melt<-utils::read.csv(rawFile,skip=skip,sep=sep,stringsAsFactors=FALSE)
  }
  if(is.numeric(meltFile)|is.null(meltFile)){
    ts<-meltFile
  }else{
    if(grepl('.xlsx?$',meltFile)){
      if(meltRawTab %in% readxl::excel_sheets(meltFile)) tmp<-as.data.frame(readxl::read_excel(meltFile,meltRawTab,skip=skip))
      else tmp<-data.frame('Temperature'=NA)[0,,drop=FALSE]
    }else{
      tmp<-utils::read.csv(meltFile,stringsAsFactors=FALSE,skip=skip)
    }
    colnames(tmp)<-sub('[ -]','.',colnames(tmp))
    ts<-unique(tmp[tmp$Well.Position=='A1','Temperature'])
  }
  mCols<-colnames(melt)[grep('x[0-9]+\\.m',colnames(melt))]
  for(ii in mCols)melt[,ii]<-as.numeric(gsub(',','',melt[,ii]))
  melt$col<-as.numeric(sub('[A-Z]','',melt$Well.Position))
  melt$row<-trimws(sub('[0-9]+','',melt$Well.Position))
  melt$rowNum<-sapply(melt$row,function(xx)which(LETTERS==xx))
  melt$well<-trimws(melt$Well.Position)
  melt$file<-rawFile
  #assumes in correct order
  if(correctCycles)melt$Cycle<-stats::ave(melt$Cycle,melt$Well.Position,FUN=function(xx)1:length(xx))
  melt$Cycle<-melt$Cycle-skipCycles
  melt<-melt[melt$Cycle>0,]
  colnames(melt)<-sub('^[Xx]([0-9])[._][mM]([0-9])','x\\1.m\\2',colnames(melt))
  flNames<-c('x1.m1'='520nm','x2.m2'='558nm','x3.m3'='587nm','x4.m4'='623nm','x5.m5'='682nm','x6.m6'='711nm')
  flNames<-flNames[names(flNames) %in% colnames(melt)]
  for(ii in names(flNames))melt[,flNames[ii]]<-melt[,ii]
  lamp<-melt[melt$Cycle<meltStart,]
  lamp$time<-lamp$Cycle*timePerCyle
  lamp$timeMin<-lamp$Cycle*timePerCyle/60
  #hardcoded magic number 5 cycles
  for(ii in names(flNames))lamp[,sprintf('%s - baseline',flNames[ii])]<-stats::ave(lamp[,flNames[ii]],lamp$well,FUN=function(xx)xx-mean(xx[1:5]))
  #max to make sure we don't get 1:0
  meltCurve<-melt[melt$Cycle %in% (meltStart+1:max(1,length(ts))-1),]
  meltCurve$temp<-ts[meltCurve$Cycle-meltStart+1]
  if(length(ts)==0)meltCurve<-NULL
  extra<-melt[melt$Cycle > meltStart+length(ts)-1,]
  return(list(lamp=lamp,melt=meltCurve,extra=extra))
}
